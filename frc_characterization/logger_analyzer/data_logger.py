# Adapted from the pynetworktables json_logger example program
#
# While this is designed to work with the autogenerated robot code from the
# Robot.java.mako file in the templates directory, it will work with any user
# code that interacts correctly with the NT interface.
#
# The expected NT interface is as follows:
#
# - /robot/autospeed : This program sends this to the robot. In autonomous mode,
#                      the robot should attempt to drive at this speed
#
# - /robot/telemetry : The robot sends this. It is a number array that contains:
#                      - time, battery, autospeed,
#                        lmotor_volts, rmotor_volts,
#                        l_encoder_count, r_encoder_count,
#                        l_encoder_velocity, r_encoder_velocity

import logging
import os
import queue
import threading
import time
import numpy as np
from tkinter import messagebox, Checkbutton, Label
from tkinter import StringVar, DoubleVar, BooleanVar

from frc_characterization.newproject import Tests, Units
import frc_characterization.logger_gui as logger_gui
from frc_characterization.logger_gui import Test

from frc_characterization.logger_analyzer.data_analyzer import (
    AUTOSPEED_COL,
    L_ENCODER_P_COL,
    R_ENCODER_P_COL,
    GYRO_ANGLE_COL,
)

from networktables import NetworkTables
from networktables.util import ntproperty

logger = logging.getLogger("logger")

# FMSControlData bitfields
ENABLED_FIELD = 1 << 0
AUTO_FIELD = 1 << 1
TEST_FIELD = 1 << 2
EMERGENCY_STOP_FIELD = 1 << 3
FMS_ATTACHED_FIELD = 1 << 4
DS_ATTACHED_FIELD = 1 << 5
timeout = 10
num_columns = 10


def translate_control_word(value):
    value = int(value)
    if value & ENABLED_FIELD == 0:
        return "disabled"
    if value & AUTO_FIELD:
        return "auto"
    if value & TEST_FIELD:
        return "test"
    else:
        return "teleop"


class TestRunner:

    # Change this key to whatever NT key you want to log
    log_key = "/robot/telemetry"

    matchNumber = ntproperty("/FMSInfo/MatchNumber", 0, writeDefault=False)
    eventName = ntproperty("/FMSInfo/EventName", "unknown", writeDefault=False)

    autospeed = ntproperty("/robot/autospeed", 0, writeDefault=True)
    rotate = ntproperty("/robot/rotate", False, writeDefault=False)

    def __init__(self, STATE):

        self.STATE = STATE

        self.STATE.trw_completed = StringVar(self.STATE.mainGUI)
        self.STATE.trw_completed.set("Not run")

        self.STATE.rotation_voltage = DoubleVar(self.STATE.mainGUI)
        self.STATE.rotation_voltage.set(2)

        self.stored_data = {}

        self.queue = queue.Queue()
        self.mode = "disabled"
        self.data = []
        self.lock = threading.Condition()

        # Tells the listener to not store data
        self.discard_data = True

        # Last telemetry data received from the robot
        self.last_data = (0,) * 20

    def connectionListener(self, connected, info):
        # set our robot to 'disabled' if the connection drops so that we can
        # guarantee the data gets written to disk
        if not connected:
            self.valueChanged("/FMSInfo/FMSControlData", 0, False)

        self.queue.put("connected" if connected else "disconnected")

    def valueChanged(self, key, value, isNew):

        if key == "/FMSInfo/FMSControlData":

            mode = translate_control_word(value)

            with self.lock:
                last = self.mode
                self.mode = mode

                data = self.data
                self.data = []

                self.lock.notifyAll()

            logger.info("Robot mode: %s -> %s", last, mode)

            # This example only stores on auto -> disabled transition. Change it
            # to whatever it is that you need for logging
            if last == "auto":
                logger.info("%d items received", len(data))

                # Don't block the NT thread -- write the data to the queue so
                # it can be processed elsewhere
                self.queue.put(data)

        elif key == self.log_key:
            logger.info("Data updated")
            self.last_data = value

            if not self.discard_data and self.mode == "disabled":
                logger.info("running disabled")
                with self.lock:
                    self.data.append(value)
                    dlen = len(self.data)

                if dlen and dlen % 100 == 0:
                    logger.info(
                        "Received %d datapoints (last commanded speed: %.2f)",
                        dlen,
                        value[AUTOSPEED_COL],
                    )

    def get_nowait(self, timeout=None):
        try:
            return self.queue.get(block=False, timeout=timeout)
        except queue.Empty:
            return queue.Empty

    def wait_for_stationary(self):
        # Wait for the velocity to be 0 for at least one second
        logger.info("Waiting for robot to stop moving for at least 1 second...")

        first_stationary_time = time.monotonic()
        last_l_encoder = 0
        last_r_encoder = 0

        while True:
            # check the queue in case we switched out of auto mode
            qdata = self.get_nowait()
            if qdata != queue.Empty:
                return qdata

            now = time.monotonic()

            # check the encoder position values, are they stationary?
            last_data = self.last_data

            try:
                l_encoder = last_data[L_ENCODER_P_COL]
                r_encoder = last_data[R_ENCODER_P_COL]
            except IndexError:
                print(self.last_data)
                raise

            if (
                abs(last_l_encoder - l_encoder) > 0.01
                or abs(last_r_encoder - r_encoder) > 0.01
            ):
                first_stationary_time = now
            elif now - first_stationary_time > 1:
                logger.info("Robot has waited long enough, beginning test")
                return

            last_l_encoder = l_encoder
            last_r_encoder = r_encoder

    def ramp_voltage_in_auto(self, initial_speed, ramp, rotate):

        logger.info(
            "Activating robot at %.1f%%, adding %.3f per 50ms", initial_speed, ramp
        )

        if rotate == None:
            rotate = self.STATE.angular_mode.get()
        self.rotate = rotate
        self.discard_data = False
        self.autospeed = initial_speed / 12
        NetworkTables.flush()

        try:
            while True:
                # check the queue in case we switched out of auto mode
                qdata = self.get_nowait()
                if qdata != queue.Empty:
                    return qdata

                time.sleep(0.050)
                self.autospeed = self.autospeed + (ramp * 0.05) / 12

                NetworkTables.flush()
        finally:
            self.autospeed = 0

    def runTest(self, name, initial_speed, ramp, finished, rotate=None):
        try:
            # Initialize the robot commanded speed to 0
            self.autospeed = 0
            self.discard_data = True
            self.STATE.postTask(
                lambda: messagebox.showinfo(
                    "Running " + name,
                    "Please enable the robot in autonomous mode, and then "
                    + "disable it before it runs out of space.\n"
                    + "Note: The robot will continue to move until you disable it - "
                    + "It is your responsibility to ensure it does not hit anything!",
                    parent=self.STATE.mainGUI,
                )
            )

            # Wait for robot to signal that it entered autonomous mode
            with self.lock:
                self.lock.wait_for(lambda: self.mode == "auto")

            # Ramp the voltage at the specified rate
            data = self.ramp_voltage_in_auto(initial_speed, ramp, rotate)
            if data in ("connected", "disconnected"):
                self.STATE.postTask(
                    lambda: messagebox.showerror(
                        "Error!", "NT disconnected", parent=self.STATE.mainGUI
                    )
                )
                return

            # wait for robot to say it is disabled
            with self.lock:
                self.lock.wait_for(lambda: self.mode == "disabled")

            # tries to retrieve disabled data
            starttime = time.time()
            while not self.data and time.time() - starttime < timeout:
                NetworkTables.flush()
                time.sleep(0.1)

            if not self.data:
                logger.info("could not receive data")
                self.STATE.postTask(
                    lambda: messagebox.showerror(
                        "Timed out while trying to receive NT data",
                        "Maybe try running the test again?",
                        parent=self.STATE.mainGUI,
                    )
                )
                return
            self.discard_data = True

            # deserializes data: "1, 2, ..." -> [[1,2,...],...]
            data = self.data[0].split(", ")  # turns the string sent into list
            data = np.array(
                [float(s) for s in data[0:-1]]
            )  # turns the string values into floats
            data = (
                np.reshape(data, (-1, num_columns))
            ).tolist()  # converts list to 2d array

            # output sanity check
            if len(data) < 3:
                self.STATE.postTask(
                    lambda: messagebox.showwarning(
                        "Warning!",
                        "Last run produced an unusually small amount of data",
                        parent=self.STATE.mainGUI,
                    )
                )
            else:
                if name == "track-width":
                    gyro_distance = data[-1][GYRO_ANGLE_COL] - data[0][GYRO_ANGLE_COL]
                    gyro_distance = round(
                        (gyro_distance * Units.RADIANS.unit).to(Units.DEGREES.unit), 3
                    )
                    self.STATE.postTask(
                        lambda: messagebox.showinfo(
                            name + " Complete",
                            f"The robot reported rotating the following angle:\n{gyro_distance}\n"
                            + "If that seems wrong, you should change the gyro calibration "
                            + "in the robot program or check your gyro setup",
                            parent=self.STATE.mainGUI,
                        )
                    )
                else:
                    left_distance = (
                        data[-1][L_ENCODER_P_COL] - data[0][L_ENCODER_P_COL]
                    ) * self.STATE.units_per_rot.get()
                    right_distance = (
                        data[-1][R_ENCODER_P_COL] - data[0][R_ENCODER_P_COL]
                    ) * self.STATE.units_per_rot.get()

                    self.STATE.postTask(
                        lambda: messagebox.showinfo(
                            name + " Complete",
                            "The robot reported traveling the following distance:\n"
                            + "Left:  %.3f %s" % (left_distance, self.STATE.units.get())
                            + "\n"
                            + "Right: %.3f %s"
                            % (right_distance, self.STATE.units.get())
                            + "\n"
                            + "If that seems wrong, you should change the encoder calibration "
                            + "in the robot program or fix your encoders!",
                            parent=self.STATE.mainGUI,
                        )
                    )

            self.stored_data[name] = data

        finally:
            self.autospeed = 0
            self.STATE.postTask(finished)


def main(team, dir, units=Units.ROTATIONS, units_per_rot=1, test=Tests.SIMPLE_MOTOR):
    logger_gui.main(team, dir, TestRunner, units, units_per_rot, test)


if __name__ == "__main__":

    main(0, os.getcwd())
